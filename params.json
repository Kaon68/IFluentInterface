{"name":"IFluentInterface","tagline":"Clean, uncluttered fluent APIs in .NET","body":"IFluentInterface\r\n================\r\n\r\nIn modern fluent APIs, [method chaining](http://en.wikipedia.org/wiki/Method_chaining) is a key techique for intuitive discovery of valid options when configuring some underlying object. \r\n\r\nIn these scenarios, [System.Object](http://msdn.microsoft.com/en-us/library/system.object.aspx) methods (Equals, GetHashCode, GetType and ToString) only contribute clutter to Visual Studio intellisense. Everyone knows those members are always there, yet they are seldom used explicitly. This is quite annoying for fluent APIs that define the flow of invocations in terms of interfaces and usually have few members at each \"step\" of the method chaining statement.\r\n\r\nFor example, in the following [Moq](https://github.com/Moq) setup, at the particular step in the statement, there is only one \"real\" invocation that makes sense (Verifiable). However, it is obscured by the System.Object members:\r\n\r\n![Full Intellisense](https://raw.github.com/clariuslabs/IFluentInterface/master/images/full-intellisense.png)\r\n\r\nA much cleaner intellisense is possible though, by simply inherinting your fluent API interfaces from the [`IFluentInterface`](https://github.com/clariuslabs/IFluentInterface/blob/master/content/IFluentInterface.cs.pp) interface provided by this project:\r\n\r\n![Clean Intellisense](https://raw.github.com/clariuslabs/IFluentInterface/master/images/clean-intellisense.png)\r\n\r\n\r\n# How to Install\r\nIFluentInterface is a single interface definition file with no external dependencies whatsoever and is distributed as a [NuGet](https://nuget.org/packages/ifluentinterface) package. It can be installed issuing the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console):\r\n\r\n    PM> Install-Package IFluentInterface\r\n\r\nAfter installation, the [`IFluentInterface`](https://github.com/clariuslabs/IFluentInterface/blob/master/content/IFluentInterface.cs.pp) file will be added to your project root, and its target namespace will match the current project's. There are no associated binaries at all.\r\n\r\n\r\n# How it Works\r\nThe trick comes from the [EditorBrowsableAttribute](http://msdn2.microsoft.com/en-us/library/System.ComponentModel.EditorBrowsableAttribute.aspx), which controls visibility of members in VS intellisense. To hide a member from intellisense, you apply the following attribute to it:\r\n\r\n```\r\n[EditorBrowsable(EditorBrowsableState.Never)]\r\n```\r\n\r\nNow, you don’t want to have to override all four object members in every type just to apply the attribute. A quite elegant solution exists, which involves taking advantage of implicit interface implementation. In particular, you can define an interface that re-defines all object members and applies the attribute:\r\n\r\n```\r\n[EditorBrowsable(EditorBrowsableState.Never)]\r\npublic interface IFluentInterface\r\n{\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    Type GetType();\r\n \r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    int GetHashCode();\r\n \r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    string ToString();\r\n \r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    bool Equals(object obj);\r\n}\r\n```\r\n\r\nNow you simply \"implement\" this interface in all your classes or interfaces where you want to hide these members, like:\r\n\r\n```\r\npublic interface IVerifies : IFluentInterface\r\n```\r\n\r\n\r\n# Who's Using This?\r\nPretty much every project that has a fluent API. Over time, I’ve started liking the `IFluentInterface` name better than my original `IHideObjectMembers`, but you can also find this interface defined as `IFluentSyntax` too.\r\n\r\nAs of 7/2013, I've found [50+ repositories using IFluentInterface](https://github.com/search?q=%22interface+IFluentInterface%22&type=Code&ref=searchresults), [70+ using IHideObjectMembers](https://github.com/search?q=%22interface+IHideObjectMembers%22&type=Code&ref=searchresults) and [16 using IFluentSyntax](https://github.com/search?q=%22interface+IFluentSyntax%22&type=Code&ref=searchresults), on GitHub only! And 40+ using one form or another via the [Ohloh source indexing service](http://code.ohloh.net/search?s=idef%3AIFluentInterface&browser=Default&filterChecked=true). \r\n\r\n\r\n# Credits\r\nIf you do leverage this technique, please maintain the original file credits as shown in [the source file](https://github.com/clariuslabs/IFluentInterface/blob/master/content/IFluentInterface.cs.pp). Our preference is for you to just install the [IFluentInterface](http://nuget.org/packages/ifluentinterface) nuget to get the interface and keep it up to date.\r\n","google":"UA-3240245-8","note":"Don't delete this file! It's used internally to help with page regeneration."}